<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rendering the Ocean with OpenGL</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
      type="text/javascript"
    ></script>
  </head>
  <body class="bg-gray-50 text-gray-800 font-sans min-h-screen flex flex-col">
    <!-- Hero/Header Section -->
    <header
      class="relative bg-cover bg-center h-64 flex flex-col justify-center items-center text-center text-white shadow mb-12"
      style="background-image: url('../../resources/LeafBorder1.png')"
    >
      <div
        class="bg-black bg-opacity-40 w-full h-full absolute top-0 left-0 z-0"
      ></div>
      <div class="z-10">
        <h1 class="text-5xl font-extrabold drop-shadow-lg text-slate-100 mb-2">
          Joel Meuleman
        </h1>
        <h2 class="text-2xl font-semibold drop-shadow mb-2">
          Rendering the Ocean with OpenGL
        </h2>
        <p class="text-lg text-slate-200">2025-06-12</p>
      </div>
    </header>
    <!-- Main Content -->
    <main class="flex-1 w-full flex justify-center px-2">
      <article
        class="bg-white rounded-lg shadow p-8 max-w-3xl w-full prose prose-lg"
      >
        <h2 id="introduction">Introduction</h2>
        <p>
          I've always enjoyed staring at the ocean. But what if we had the ocean
          at home on the computer? This is the question I bravely asked as I set
          out to implement an OpenGL program to mimic the ocean.
        </p>
        <h2 id="why-opengl-also-some-vocab">Why OpenGL? (also some vocab)</h2>
        <p>
          <strong>OpenGL</strong> - Low level cross-platform graphics
          programming API.<br />
          <strong>Shader</strong> - Program that runs on the GPU.
        </p>
        <hr />
        <p>
          Why suffer through the pain of using OpenGL instead of using a
          higher-level graphics framework or library? As an engineer, wanting to
          know how things work is inherent to who I am. Programming at a low-ish
          level like this provides several benefits: it forces me to think
          harder about making my own abstractions, and it teaches me about
          (in)efficiencies with different implementations. Both these skills
          come in handy when debugging code made with higher level tools.
        </p>
        <p>
          <em>
            As an aside, this post is not about teaching OpenGL basics, but
            rather about how a complex looking graphic can be from small simple
            pieces.
          </em>
        </p>
        <h2 id="step-by-step-implementation">Step by Step Implementation</h2>
        <h3 id="initial-planning">Initial Planning</h3>
        <p>
          To begin, I should mention we’ll be doing the rendering through
          rasterization (as opposed to ray tracing/marching). This means we’ll
          be describing a scene in 3D space, then doing some algebra to project
          this 3D world onto a 2D plane which determines our pixel colours. To
          render this scene, I’ll generate a plane of vertices, then displace
          these vertices with a wave function. Later, I’ll put this plane in a
          skybox when it’s time to make the waves look a bit more realistic with
          reflections. The final executable will utilize 2 shader programs: one
          to render the waves, and one to render the background.
        </p>
        <h3 id="rendering-a-plane">Rendering a Plane</h3>
        <p>
          Let’s first start by generating points for and rendering a simple
          plane. We generate evenly spaced points and record their index
          ordering for passing to the EBO for rendering.
        </p>
        <p>
          In the vertex shader, I displace the vertical position with a sine
          function <span class="math display">\[p = (x,sin(x,z), z)\]</span> In
          the fragment shader, I assign a purple colour to each pixel in the
          mesh. Finally, I displace the camera slightly so we can view the
          plane.
        </p>
        <video
          src="./blog-wave-resources/wave.mov"
          controls
          class="my-4 rounded shadow"
        ></video>
        <p>
          We have a wave! We can see we have motion and depth, but it would be
          nice if we had a bit of lighting off the surface of the mesh, so that
          we can better tell what’s going on.
        </p>
        <h3 id="lighting">Lighting</h3>
        <p>
          For this shader program, I chose to implement
          <a href="https://learnopengl.com/Lighting/Basic-Lighting"
            >Blinn-Phong</a
          >
          lighting. This is a fundamental lighting model in computer graphics,
          and it’s extensible for adding later lighting features. There are 3
          aspects to Blinn Phong lighting: ambient, specular, and diffuse light.
        </p>
        <p>
          To begin implementing this lighting method, the surface normal for
          each vertex is required. Thankfully, as we have a simple function for
          the displacement of each vertex, we have a simple derivative that will
          give us the <strong>exact</strong> normal for each vertex
          <span class="math display">\[dy/dx = cos(x)\]</span> Using the normal
          as calculated in the vertex shader we calculate the lighting
          contribution for each pixel.
        </p>
        <video
          src="./blog-wave-resources/lit-wave.mov"
          controls
          class="my-4 rounded shadow"
        ></video>
        <p>
          Nice! With the basic lighting done, we can implement more complex wave
          patterns.
        </p>
        <h3 id="improving-the-wave-displacement-algorithm">
          Improving the Wave Displacement Algorithm
        </h3>
        <p>
          With the basics out of the way, it’s time to look at more realistic
          wave algorithms for displacing our plane vertices.
          <a
            href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models"
            >GPU Gems</a
          >
          describes how we can achieve more complex looking waves using a sum of
          sines calculation.
          <span class="math display"
            >\[ y=\sum_{i = 0}^{N}{f(x)} \hspace{12pt} \text{and} \hspace{12pt}
            \frac{dy}{dx}=\sum_{i = 0}^{N}{f'(x)} \]</span
          >
          Thankfully, the derivative of the sum equals the sum of the
          derivative, which means we can more or less wrap our displacement and
          normal calculations in a loop. After adding some pseudo randomly
          generated wave parameters, and summing just 4 waves, we arrive at this
          animation.
        </p>
        <video
          src="./blog-wave-resources/ss.mov"
          controls
          class="my-4 rounded shadow"
        ></video>
        <p>
          Then, we change our wave function to one with steeper peaks and lower
          troughs by updating the displacement and normal computations in the
          vertex shader.
          <span class="math display"
            >\[ W_i(x, z, t) = 2A_i \times \left( \frac{\sin(\mathbf{D}_i \cdot
            (x, z) \times w_i + t \times \varphi_i) + 1}{2} \right)^k \]</span
          >
          <span class="math display"
            >\[ \frac{\partial}{\partial x}(W_i(x, z, t)) = k \times
            \mathbf{D}_i.x \times w_i \times A_i \times \left(
            \frac{\sin(\mathbf{D}_i \cdot (x, z) \times w_i + t \times
            \varphi_i) + 1}{2} \right)^{k-1} \times \cos(\mathbf{D}_i \cdot (x,
            z) \times w_i + t \times \varphi_i). \]</span
          >
        </p>
        <p>
          This surface has more complexity, and we can spend time tweaking
          values to get exactly what we want later.
        </p>
        <video
          src="./blog-wave-resources/ss-exp.mov"
          controls
          class="my-4 rounded shadow"
        ></video>
        <h3 id="adding-a-skybox-and-reflections">
          Adding a Skybox and Reflections
        </h3>
        <p>
          In this stage, we add more realism to our surface by adding an
          atmosphere to view in the distance. To be somewhat realistic, this
          atmosphere must also be reflected off the surface of the water.
        </p>
        <p>
          We implement the skybox as a separate shader. We define a box
          surrounding our wave plane, and map a nice sky picture to it. In the
          fragment shader of the wave shader, we sample the skybox texture to
          determine what colour to reflect off the surface pixel. After
          implementing these changes, we arrive at this
        </p>
        <video
          src="./blog-wave-resources/skybox.mov"
          controls
          class="my-4 rounded shadow"
        ></video>
        <p>
          With some more tweaks that I’ll write about later (mostly stolen from
          <a href="https://www.youtube.com/watch?v=PH9q0HNBjT4&t=1054s"
            >Acerola’s video</a
          >) I got this animation.
        </p>
        <video
          src="./blog-wave-resources/tweaked-params.mov"
          controls
          class="my-4 rounded shadow"
        ></video>
        <h3 id="conclusion">Conclusion</h3>
        <p>
          Over the course of a couple sections, we’ve shown how we can implement
          a complex looking animation through little more than some basic
          calculus and linear algebra. I’ll likely post a follow-up blog where I
          implement a more realistic wave function, but this seems like a good
          place to stop without adding too much extra detail.
        </p>
        <h2 id="references">References</h2>
        <ul>
          <li>
            <a
              href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models"
              >GPU Gems</a
            >
          </li>
          <li>
            <a href="https://www.youtube.com/watch?v=PH9q0HNBjT4&t=1054s"
              >Acerola</a
            >
          </li>
        </ul>
      </article>
    </main>
    <!-- Footer -->
    <footer class="bg-white border-t w-full mt-12">
      <div
        class="max-w-4xl mx-auto px-4 py-6 text-center text-sm text-gray-500"
      >
        &copy; 2025 Joel Meuleman
      </div>
    </footer>
  </body>
</html>
